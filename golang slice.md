# golang-slice底层分析
## 一. 切片和数组
```
关于切片和数组怎么选择？接下来好好讨论讨论这个问题。

在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。
Go中的slice依赖于数组，它的底层就是数组，所以数组具有的优点，slice都有。    
slice自身维护了一个指针属性，指向它底层数组中的某些元素的集合
```
务必记住slice的本质是[x/y]0xADDR，记住它将在很多地方有助于理解slice的特性。另外，个人建议，虽然slice的本质不是指针，但仍然可以将它看作是一种包含了另外两种属性的不纯粹的指针，也就是说，直接认为它是指针
## 二. make new
```
内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针
内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型
make()比new()函数多一些操作，new()函数只会进行内存分配并做默认的赋0初始化，而make()可以先为底层数组分配好内存，然后从这个底层数组中再额外生成一个slice并初始化

为什么slice、map和channel要由make创建呢？
只有make 用于可以初始化其内部的数据结构并准备好将要使用的值。
```
## 三. array  slice
```
在golang中有数组和Slice两种数据结构，Slice是基于数组的实现，是长度动态不固定的数据结构，本质上是一个对数组字序列的引用，提供了对数组的轻量级访问。那么在go的函数中以数组或Slice为形参的时候就存在一些差别。
​ 首先，golang中是值传递，并且如果传递的参数是数组的时候并不会隐式将数组作为引用或者指针传入，而是传入副本，而如果想轻量级传递数据，这个时候就需要使用slice了。
```
## 四. golang 的全部类型
```
​ 这个是官方给的类型, 只有两种 一种是数值类型一种是派生类型.

## 数值类型

###布尔型

    bool 布尔型的值只可以是常量 true 或者 false，默认值为 false。

###字符串类型

    string 编码统一为 UTF-8 编码标识 Unicode 文本，默认值为空字符串。

###整型（默认值为 0）

    uint8： 无符号 8 位整型（0 ~ 255）；
    uint16：无符号 16 位整型（0 ~ 65535）；
    uint32：无符号 32 位整型（0 ~ 4294967295）；
    uint64：无符号 64 位整型（0 ~ 18446744073709551615）；
    int8：有符号 8 位整型（-128 ~ 127）；
    int16：有符号 16 位整型（-32768 ~ 32767）；
    int32：有符号 32 位整型（-2147483648 ~ 2147483647）；
    int64：有符号 64 位整型（-9223372036854775808 ~ 9223372036854775807）
###浮点型（默认值为 0）

    float32：IEEE-754 32 位浮点数；
    float64：IEEE-754 64 位浮点数；
    complex64：32 位实数和虚数；
    complex128：64 位实数和虚数；
###其他数值类型

    byte：类似 uint8；
    rune：类似 int32；
    uint：32 或 64 位；
    int：与 uint 一样大小；
    uintptr：无符号整型，用于存放一个指针；
## 派生类型

    指针类型（Pointer）
    数组类型 ([len]byte)
    结构化类型（struct）
    Channel 类型（chan）
    函数类型（func）
    切片类型（slice）
    接口类型（interface）
    Map 类型（map）

```
## 五.指针和引用
```
指针变量存储的是另一个变量的地址。
引用变量指向另外一个变量。
指针可以重分配，而引用不能。换句话说，指针可以被分配另一个不同的地址。
```
## 六. nil slice和空slice
```
nil slice表示它的指针为nil，也就是这个slice不会指向哪个底层数组。也因此，nil slice的长度和容量都为0。
还可以创建空slice(Empty Slice)，空slice表示长度为0，容量为0，但却有指向的slice，只不过指向的底层数组暂时是长度为0的空数组
对slice进行切片,可以从slice中继续切片生成一个新的slice，这样能实现slice的缩减。
```
## 七. append()函数  扩容
```
append()返回一个新的slice，原始的slice会保留不变。



当slice的length已经等于capacity的时候，再使用append()给slice追加元素，会自动扩展底层数组的长度。
底层数组扩展时，会生成一个新的底层数组。所以旧底层数组仍然会被旧slice引用，新slice和旧slice不再共享同一个底层数组。

当底层数组需要扩容时，会按照当前底层数组长度的2倍进行扩容，并生成新数组。如果底层数组的长度超过1000时，将按照25%的比率扩容，也就是1000个元素时，将扩展为1250个，不过这个增长比率的算法可能会随着go版本的递进而改变。
通常会切出仅一个长度、仅一个容量的新slice，这样只要对它进行任何一次扩容，就会生成一个新的底层数组，从而让每个slice的底层数组都独立。
```
## 八.slice和内存浪费问题
```
由于slice的底层是数组，很可能数组很大，但slice所取的元素数量却很小，这就导致数组占用的绝大多数空间是被浪费的。

特别地，垃圾回收器(GC)不会回收正在被引用的对象，当一个函数直接返回指向底层数组的slice时，这个底层数组将不会随函数退出而被回收，而是因为slice的引用而永远保留，除非返回的slice也消失。

因此，当函数的返回值是一个指向底层数组的数据结构时(如slice)，应当在函数内部将slice拷贝一份保存到一个使用自己底层数组的新slice中，并返回这个新的slice。这样函数一退出，原来那个体积较大的底层数组就会被回收，保留在内存中的是小的slice。
```

